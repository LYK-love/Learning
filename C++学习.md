>  Reference:
>
> > Language:
> >
> > C++ Primer
> >
> > Effective C++
> >
> > More Effective C++
> >
> > Effective Modern C++
>
> > Design:
> >
> > Design Patterns
> >
> > Pattern-oriented Software Architecture



**G = ( VN , VT , P , Z )**

>  VN : `non-terminal`,非终结符号
>
>  VT:终结符号
>
> P:规则
>
> Z：target，目标

高级程序设计语言都是有理论保障的，不然不能保证我们得到正确的结果。



## Programming 

看待程序设计的两个观点：

* The **Science** of programming: 从科学的角度。从这个角度看，许多bug是来自数据流而不是程序本身。
* The **Art** of programming:从艺术的角度。程序设计要时刻注意所处的设计环境。



Von-Neumann structure: 计算器、存储器、控制器、IO

Programming Paradigm

* Procedure:  最经典的就是 程序 = 数据结构 + 算法
* Object-Oriented: OO是对人来说的， 依然在冯诺依曼架构里。
* Functional: 典型的就是 f( g(x) )  =  g( f( x ) ),  在java程序中，如果函数有副作用，那这个式子是不成立的，而函数式就要确保函数没有副作用，这就能满足数学上的表达。这种没有副作用的场景是非常多的，比如说分布式计算就依赖于此
* Logical: 规则 + 条件 → automatic proof



## 基本数据类型 built-in datatype

* `char`,`int` , `float` , `double`

* Modifiers: long , short , signed , unsigned

  * `char` 只能用`signed`,`unsigned`修饰
  * `float`不能被修饰
  * `double`只能用`long`修饰
  * `int`可以用四种修饰符组合修饰

* 省略表示

* 操作符`sizeof`

* ANSI C++: `wcchar_t`,`bool`

* typedef

  * 为**已有**的类型定义一个同义词：

  `typedef int INT32;`

  `typedef int A[8];`

## 表达式

* 组成

  * operand
  * operator
  * others

* 求值

  * 优先级

  * 结合性

  * 类型转换约定: 所有计算,规定的都是*同类型*计算. 对于混合运算,我们采取类型转换.有**默认类型转换**( Type Coercion ,  可以查文档) , 也可以强制地改变类型转换约定( Type Casting )( 这可以让你从宽的往窄的地方转, compiler会给一个`warning`,结果你自己负责 ). 我们也可以自己定义各种混合类型的计算.

    * 类型转换是按照计算顺序**逐个**进行的

    * 类型转换精度: 浮点数不能精确表达整数,会有精度损失. 因此`int`默认转成`double`(一定能得到正确答案) 而不是`float`

      

  * 求值次序

    * 取决于Compiler,不是嘴上说说的

    * token:具有独立意义的最小语法单位

    * 代码由编译器翻译为机器码,而编译器中一个重要的功能就是`Optimization`,因此

      `x = 1 + 2 + 3;` 和 `a = 1 + 2 ; x = a + 3` 性能是一样的,所以**没必要为了性能而写出很晦涩的表达式,其实性能都一样**

  * overflow:

    * 加法: 判断结果是否为`0`或者`负数`
    * 减法: 看作加法 ,但是要注意补码特征的问题,如 `min` (`10000...`)取反加一之后还是 `min` 
    * 乘法: 也要注意补码特征问题
    * 除法: 不能除以0.   `-min / -1`有问题,别的都没问题

* 种类

  注意表达式不是语句. `x=1`是表达式,加上**分号**之后`x=1;`才是**表达式语**句. `1`是表达式, `1;`是表达式语句

  * 算数
  * 关系和逻辑
  * 赋值

  * 逗号
  * 字位运算符

* 操作符可重载

  ​	增加语言灵活性. 

  ​	*不是所有操作符都能重载,比如逗号*

  ​	重载后的操作符不能与原来语义相违背,比如`&&`重载后会失去`短路效果`,所以一般不重载`&&`

* 赋值表达式

  *左值 = 右值表达式*

  * 左值: 可以出现在赋值表达式左部的*表达式*,具有存放数据的**确定**地址
  * 类型不同时,先计算右值表达式的值,再转换为左值类型,如`double d = 5/2`,右边会先计算出`2`,然后转为`2.0`

* 算术表达式

  * 增量和简练操作符
    * 前增量(前减量) `++a `     *// 前增量的结果是左值*
    * 后增量(后减量) `--a`
    * 提高编译后的执行效率

* 条件运算符表达式

  * <exp1>?<exp2>:<exp3>

  * 唯一的三目运算符
  * 只计算一个分量
  * 如果<exp2>和<exp2>的值类型相同,且均为左值,则该条件运算符表达式为左值表达式
  * 可嵌套
    * sign(x) `x > 0 ? 1 : x==0? 0 : -1`
    * 就近原则

* 逗号表达式

  * <exp1>,<exp2>,<exp3>...<expn>

  * <expn>的值作为该逗号表达式的值

    ```
    int a,b,c;
    	d = ( a = 1 , b = a + 2 , c = b + 3);
    cout << d << endl; // 6
    ```

  * 如<expn>为左值,则该逗号表达式为左值表达式

* 字位运算符表达式

  * 对整型数二进制位(bit)的操作,将整型数看作二进制序列

  * 与同一个对象异或两次,结果不变( 结合性 )

* 移位运算符表达式

## 语句

* 表达式语句
* IO语句
  * `cin`,`cout`
  * `>>`,`<<`可重载 .   现在它们变成操作符了. `cin<<x`是一个表达式

* 控制流语句

  * 顺序,选择,重复

  

  

  

  

  

  

  

  

  

  

  

  

  

  







